// TMDBResponse represents the TMDB API response// createDirectories creates necessary directories if they don't existpackage main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"

	"github.com/gin-gonic/gin"
)

// TMDB API configuration
const (
	TMDB_BASE_URL  = "https://api.themoviedb.org/3"
	IMAGE_BASE_URL = "https://image.tmdb.org/t/p/w500" // w500 for medium quality images
	AUTH_TOKEN     = "Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIwZjQzNWJiZWRhY2M0NDk3MWMxNDc1MTNkYjJmZWU2MiIsIm5iZiI6MTc1MzQ1NzY4Ni42OTQwMDAyLCJzdWIiOiI2ODgzYTQxNjQ4ZWE1NTk3MzM1NWU5NzMiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.RbZg1YOqjIUcqo3C5T5GzumDBEDDi7KFi85Md91coIg"
)

// Movie represents a movie from TMDB API
type Movie struct {
	ID           int    `json:"id"`
	Title        string `json:"title"`
	PosterPath   string `json:"poster_path"`
	BackdropPath string `json:"backdrop_path"`
	Overview     string `json:"overview"`
	ReleaseDate  string `json:"release_date"`
	GenreIds     []int  `json:"genre_ids"`
	Runtime      int    `json:"runtime"`
}

// Genre represents a genre from TMDB
type Genre struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// Director represents a director from TMDB movie credits
type Director struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// TMDBGenres contains all the genre mappings
var TMDBGenres = []Genre{
	{28, "Action"},
	{12, "Adventure"},
	{16, "Animation"},
	{35, "Comedy"},
	{80, "Crime"},
	{99, "Documentary"},
	{18, "Drama"},
	{10751, "Family"},
	{14, "Fantasy"},
	{36, "History"},
	{27, "Horror"},
	{10402, "Music"},
	{9648, "Mystery"},
	{10749, "Romance"},
	{878, "Science Fiction"},
	{10770, "TV Movie"},
	{53, "Thriller"},
	{10752, "War"},
	{37, "Western"},
}

type TMDBResponse struct {
	Page         int     `json:"page"`
	Results      []Movie `json:"results"`
	TotalPages   int     `json:"total_pages"`
	TotalResults int     `json:"total_results"`
}

// DownloadResult represents the result of downloading images for a movie
type DownloadResult struct {
	MovieID       int    `json:"movie_id"`
	Title         string `json:"title"`
	PosterSaved   bool   `json:"poster_saved"`
	BackdropSaved bool   `json:"backdrop_saved"`
	PosterPath    string `json:"poster_path,omitempty"`
	BackdropPath  string `json:"backdrop_path,omitempty"`
	SQLGenerated  bool   `json:"sql_generated"`
	Error         string `json:"error,omitempty"`
}

// fetchMovieDetails fetches detailed movie information including runtime
func fetchMovieDetails(movieID int) (*Movie, error) {
	url := fmt.Sprintf("%s/movie/%d?language=en-US", TMDB_BASE_URL, movieID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", AUTH_TOKEN)

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var movie Movie
	if err := json.Unmarshal(body, &movie); err != nil {
		return nil, err
	}

	return &movie, nil
}

// generateSQLSeeds generates SQL INSERT statements for all tables
func generateSQLSeeds(movies []Movie) string {
	var sql strings.Builder

	// Header comment
	sql.WriteString("-- Database seed for movies, genres, and movie_genres tables\n")
	sql.WriteString("-- Generated by TMDB Movie Downloader\n\n")

	// Insert genres first
	sql.WriteString("-- Insert genres\n")
	sql.WriteString("INSERT INTO genres (id, name) VALUES\n")
	for i, genre := range TMDBGenres {
		if i > 0 {
			sql.WriteString(",\n")
		}
		sql.WriteString(fmt.Sprintf("    (%d, '%s')", genre.ID, genre.Name))
	}
	sql.WriteString("\nON CONFLICT (id) DO NOTHING;\n\n")

	// Insert movies
	sql.WriteString("-- Insert movies\n")
	for _, movie := range movies {
		title := strings.ReplaceAll(movie.Title, "'", "''")
		synopsis := strings.ReplaceAll(movie.Overview, "'", "''")

		// Handle NULL runtime
		runtimeStr := "NULL"
		if movie.Runtime > 0 {
			runtimeStr = fmt.Sprintf("%d", movie.Runtime)
		}

		// Handle release_date format (convert from YYYY-MM-DD to proper date)
		releaseDateStr := "NULL"
		if movie.ReleaseDate != "" {
			releaseDateStr = fmt.Sprintf("'%s'", movie.ReleaseDate)
		}

		sql.WriteString(fmt.Sprintf(
			"INSERT INTO movies (title, synopsis, poster_img, backdrop_img, duration_minutes, release_date) VALUES ('%s', '%s', '%s', '%s', %s, %s);\n",
			title,
			synopsis,
			movie.PosterPath,
			movie.BackdropPath,
			runtimeStr,
			releaseDateStr,
		))
	}
	sql.WriteString("\n")

	// Insert movie_genres associations
	sql.WriteString("-- Insert movie_genres associations\n")
	for _, movie := range movies {
		for _, genreID := range movie.GenreIds {
			sql.WriteString(fmt.Sprintf(
				"INSERT INTO movie_genres (movie_id, genre_id) VALUES (%d, %d) ON CONFLICT DO NOTHING;\n",
				movie.ID,
				genreID,
			))
		}
	}

	return sql.String()
}

// initSQLFile creates/initializes the SQL file with database schema
func initSQLFile(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	schemaSQL := `-- Database seed for movies, genres, and movie_genres tables
-- Generated by TMDB Movie Downloader

-- Note: This assumes your tables already exist. 
-- If you need to create them, uncomment and modify the CREATE TABLE statements below.

/*
CREATE TABLE IF NOT EXISTS genres (
    id INTEGER PRIMARY KEY,
    name VARCHAR(20) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS movies (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    title TEXT NOT NULL,
    synopsis TEXT,
    poster_img TEXT,
    backdrop_img TEXT,
    duration_minutes INTEGER,
    release_date DATE,
    director_id INTEGER,
    age_rating_id INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    archived_at TIMESTAMPTZ
);

CREATE TABLE IF NOT EXISTS movie_genres (
    movie_id INTEGER NOT NULL,
    genre_id INTEGER NOT NULL,
    PRIMARY KEY (movie_id, genre_id),
    FOREIGN KEY (movie_id) REFERENCES movies(id),
    FOREIGN KEY (genre_id) REFERENCES genres(id)
);
*/

`

	_, err = file.WriteString(schemaSQL)
	return err
}

// writeSQLToFile writes SQL content to file
func writeSQLToFile(filename, sqlContent string) error {
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(sqlContent)
	return err
}
func createDirectories() error {
	dirs := []string{"images/posters", "images/backdrops"}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", dir, err)
		}
	}
	return nil
}

// fetchMovies fetches movies from TMDB API
func fetchMovies(page int) (*TMDBResponse, error) {
	url := fmt.Sprintf("%s/discover/movie?include_adult=false&include_video=false&language=en-US&page=%d&sort_by=popularity.desc", TMDB_BASE_URL, page)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", AUTH_TOKEN)

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var tmdbResponse TMDBResponse
	if err := json.Unmarshal(body, &tmdbResponse); err != nil {
		return nil, err
	}

	return &tmdbResponse, nil
}

// downloadImage downloads an image from the given URL and saves it to the specified path
func downloadImage(imageURL, savePath string) error {
	if imageURL == "" {
		return fmt.Errorf("empty image URL")
	}

	fullURL := IMAGE_BASE_URL + imageURL

	resp, err := http.Get(fullURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download image, status: %d", resp.StatusCode)
	}

	file, err := os.Create(savePath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = io.Copy(file, resp.Body)
	return err
}

// sanitizeFilename removes/replaces characters that are not safe for filenames
func sanitizeFilename(filename string) string {
	// Replace unsafe characters with underscores
	unsafe := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|"}
	for _, char := range unsafe {
		filename = strings.ReplaceAll(filename, char, "_")
	}
	return filename
}

// downloadMovieImages downloads poster and backdrop for a single movie
func downloadMovieImages(movie Movie) DownloadResult {
	result := DownloadResult{
		MovieID: movie.ID,
		Title:   movie.Title,
	}

	sanitizedTitle := sanitizeFilename(movie.Title)

	// Download poster
	if movie.PosterPath != "" {
		posterFilename := fmt.Sprintf("%d_%s_poster%s", movie.ID, sanitizedTitle, filepath.Ext(movie.PosterPath))
		posterPath := filepath.Join("images", "posters", posterFilename)

		if err := downloadImage(movie.PosterPath, posterPath); err != nil {
			result.Error += fmt.Sprintf("Poster download failed: %v; ", err)
		} else {
			result.PosterSaved = true
			result.PosterPath = posterPath
		}
	}

	// Download backdrop
	if movie.BackdropPath != "" {
		backdropFilename := fmt.Sprintf("%d_%s_backdrop%s", movie.ID, sanitizedTitle, filepath.Ext(movie.BackdropPath))
		backdropPath := filepath.Join("images", "backdrops", backdropFilename)

		if err := downloadImage(movie.BackdropPath, backdropPath); err != nil {
			result.Error += fmt.Sprintf("Backdrop download failed: %v; ", err)
		} else {
			result.BackdropSaved = true
			result.BackdropPath = backdropPath
		}
	}

	return result
}

// fetchAndDownload200Movies fetches and downloads images for 200 movies
func fetchAndDownload200Movies() error {
	fmt.Println("Starting to fetch and download 200 popular movies...")

	// Initialize SQL file
	sqlFilename := "movie_seeds.sql"
	if err := initSQLFile(sqlFilename); err != nil {
		return fmt.Errorf("failed to initialize SQL file: %v", err)
	}
	fmt.Printf("SQL file '%s' initialized\n", sqlFilename)

	var allResults []DownloadResult
	var allMovies []Movie
	totalMovies := 0

	// Fetch movies from multiple pages to get 200 movies
	for page := 1; totalMovies < 200; page++ {
		fmt.Printf("Fetching page %d...\n", page)

		tmdbResponse, err := fetchMovies(page)
		if err != nil {
			return fmt.Errorf("failed to fetch movies from page %d: %v", page, err)
		}

		// Process movies from this page
		moviesFromThisPage := 0
		for _, movie := range tmdbResponse.Results {
			if totalMovies >= 200 {
				break
			}

			fmt.Printf("Processing movie %d: %s\n", movie.ID, movie.Title)

			// Fetch detailed movie information (including runtime)
			detailedMovie, err := fetchMovieDetails(movie.ID)
			if err != nil {
				fmt.Printf("Warning: Could not fetch details for movie %d: %v\n", movie.ID, err)
				// Use basic movie data if detailed fetch fails
				detailedMovie = &movie
			}

			// Download images
			result := downloadMovieImages(*detailedMovie)
			allResults = append(allResults, result)
			allMovies = append(allMovies, *detailedMovie)

			totalMovies++
			moviesFromThisPage++
		}

		fmt.Printf("Processed %d movies from page %d\n", moviesFromThisPage, page)

		// If we didn't get any movies from this page, break to avoid infinite loop
		if len(tmdbResponse.Results) == 0 {
			break
		}
	}

	// Generate and write SQL seeds for all movies
	fmt.Println("Generating SQL seeds...")
	sqlSeeds := generateSQLSeeds(allMovies)
	if err := writeSQLToFile(sqlFilename, sqlSeeds); err != nil {
		return fmt.Errorf("failed to write SQL seeds: %v", err)
	}

	// Print summary
	fmt.Printf("\n=== DOWNLOAD SUMMARY ===\n")
	fmt.Printf("Total movies processed: %d\n", totalMovies)

	postersDownloaded := 0
	backdropsDownloaded := 0
	errors := 0

	for _, result := range allResults {
		if result.PosterSaved {
			postersDownloaded++
		}
		if result.BackdropSaved {
			backdropsDownloaded++
		}
		if result.Error != "" {
			errors++
			fmt.Printf("Error for '%s': %s\n", result.Title, result.Error)
		}
	}

	fmt.Printf("Posters downloaded: %d\n", postersDownloaded)
	fmt.Printf("Backdrops downloaded: %d\n", backdropsDownloaded)
	fmt.Printf("SQL seeds generated: %s\n", sqlFilename)
	fmt.Printf("Movies with errors: %d\n", errors)
	fmt.Println("SQL file contains:")
	fmt.Printf("  - %d genre records\n", len(TMDBGenres))
	fmt.Printf("  - %d movie records\n", len(allMovies))
	fmt.Printf("  - Movie-genre associations\n")
	fmt.Println("======================")

	return nil
}

func main() {
	// Create necessary directories
	if err := createDirectories(); err != nil {
		fmt.Printf("Error creating directories: %v\n", err)
		return
	}

	// Automatically fetch and download 200 movies
	if err := fetchAndDownload200Movies(); err != nil {
		fmt.Printf("Error during automatic download: %v\n", err)
		return
	}

	fmt.Println("\nAutomatic download completed!")
	fmt.Println("Starting web server for additional operations...")

	// Initialize Gin router
	r := gin.Default()

	// GET /movies - Fetch and display movies without downloading images
	r.GET("/movies", func(c *gin.Context) {
		page := 1
		if pageParam := c.Query("page"); pageParam != "" {
			if p, err := fmt.Sscanf(pageParam, "%d", &page); err != nil || p != 1 {
				page = 1
			}
		}

		tmdbResponse, err := fetchMovies(page)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		c.JSON(http.StatusOK, tmdbResponse)
	})

	// POST /download - Fetch movies and download their images
	r.POST("/download", func(c *gin.Context) {
		page := 1
		if pageParam := c.Query("page"); pageParam != "" {
			if p, err := fmt.Sscanf(pageParam, "%d", &page); err != nil || p != 1 {
				page = 1
			}
		}

		// Fetch movies from TMDB
		tmdbResponse, err := fetchMovies(page)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		// Create a new SQL file for this batch
		sqlFilename := fmt.Sprintf("movies_batch_%d.sql", page)
		if err := initSQLFile(sqlFilename); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create SQL file"})
			return
		}

		// Fetch detailed movie information and download images
		var allMovies []Movie
		var results []DownloadResult
		for _, movie := range tmdbResponse.Results {
			// Fetch detailed movie information
			detailedMovie, err := fetchMovieDetails(movie.ID)
			if err != nil {
				// Use basic movie data if detailed fetch fails
				detailedMovie = &movie
			}

			result := downloadMovieImages(*detailedMovie)
			results = append(results, result)
			allMovies = append(allMovies, *detailedMovie)
		}

		// Generate and write SQL seeds
		sqlSeeds := generateSQLSeeds(allMovies)
		if err := writeSQLToFile(sqlFilename, sqlSeeds); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to write SQL seeds"})
			return
		}

		response := gin.H{
			"page":             tmdbResponse.Page,
			"total_movies":     len(tmdbResponse.Results),
			"sql_file":         sqlFilename,
			"download_results": results,
		}

		c.JSON(http.StatusOK, response)
	})

	// POST /download/:id - Download images for a specific movie by ID
	r.POST("/download/:id", func(c *gin.Context) {
		movieID := c.Param("id")

		// Fetch specific movie details
		url := fmt.Sprintf("%s/movie/%s?language=en-US", TMDB_BASE_URL, movieID)

		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		req.Header.Add("accept", "application/json")
		req.Header.Add("Authorization", AUTH_TOKEN)

		res, err := http.DefaultClient.Do(req)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}
		defer res.Body.Close()

		if res.StatusCode != http.StatusOK {
			c.JSON(http.StatusNotFound, gin.H{"error": "Movie not found"})
			return
		}

		body, err := io.ReadAll(res.Body)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		var movie Movie
		if err := json.Unmarshal(body, &movie); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
			return
		}

		// Create SQL file for single movie
		sqlFilename := fmt.Sprintf("movie_%s.sql", movieID)
		if err := initSQLFile(sqlFilename); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create SQL file"})
			return
		}

		// Download images for the specific movie
		result := downloadMovieImages(movie)

		// Generate SQL seeds for single movie
		sqlSeeds := generateSQLSeeds([]Movie{movie})
		if err := writeSQLToFile(sqlFilename, sqlSeeds); err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to write SQL seeds"})
			return
		}

		result.SQLGenerated = true

		response := gin.H{
			"sql_file": sqlFilename,
			"result":   result,
		}

		c.JSON(http.StatusOK, response)
	})

	// GET /images/posters/:filename - Serve poster images
	r.Static("/images/posters", "./images/posters")

	// GET /images/backdrops/:filename - Serve backdrop images
	r.Static("/images/backdrops", "./images/backdrops")

	// Health check endpoint
	r.GET("/health", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"status": "ok"})
	})

	fmt.Println("Server starting on :8080")
	fmt.Println("Available endpoints:")
	fmt.Println("  GET  /movies - Fetch movies from TMDB")
	fmt.Println("  POST /download - Download images for popular movies (generates SQL file)")
	fmt.Println("  POST /download/:id - Download images for specific movie (generates SQL file)")
	fmt.Println("  GET  /images/posters/:filename - Serve poster images")
	fmt.Println("  GET  /images/backdrops/:filename - Serve backdrop images")
	fmt.Println("  GET  /health - Health check")

	r.Run(":8080")
}