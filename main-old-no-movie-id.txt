// TMDBResponse represents the TMDB API response// createDirectories creates necessary directories if they don't exist
package main

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

// TMDB API configuration
const (
	TMDB_BASE_URL  = "https://api.themoviedb.org/3"
	IMAGE_BASE_URL = "https://image.tmdb.org/t/p/w500" // w500 for medium quality images
	AUTH_TOKEN     = "Bearer eyJhbGciOiJIUzI1NiJ9.eyJhdWQiOiIwZjQzNWJiZWRhY2M0NDk3MWMxNDc1MTNkYjJmZWU2MiIsIm5iZiI6MTc1MzQ1NzY4Ni42OTQwMDAyLCJzdWIiOiI2ODgzYTQxNjQ4ZWE1NTk3MzM1NWU5NzMiLCJzY29wZXMiOlsiYXBpX3JlYWQiXSwidmVyc2lvbiI6MX0.RbZg1YOqjIUcqo3C5T5GzumDBEDDi7KFi85Md91coIg"
)

// Movie represents a movie from TMDB API
type Movie struct {
	ID           int    `json:"id"`
	Title        string `json:"title"`
	PosterPath   string `json:"poster_path"`
	BackdropPath string `json:"backdrop_path"`
	Overview     string `json:"overview"`
	ReleaseDate  string `json:"release_date"`
	GenreIds     []int  `json:"genre_ids"`
	Runtime      int    `json:"runtime"`
	DirectorID   *int   `json:"director_id,omitempty"`   // Added for director reference
	DirectorName string `json:"director_name,omitempty"` // Added for director name
}

// Genre represents a genre from TMDB
type Genre struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
}

// Person represents a person (actor/director) from TMDB
type Person struct {
	ID          int    `json:"id"`
	Name        string `json:"name"`
	ProfilePath string `json:"profile_path"`
}

// CastMember represents a cast member from credits
type CastMember struct {
	Adult              bool    `json:"adult"`
	Gender             int     `json:"gender"`
	ID                 int     `json:"id"`
	KnownForDepartment string  `json:"known_for_department"`
	Name               string  `json:"name"`
	OriginalName       string  `json:"original_name"`
	Popularity         float64 `json:"popularity"`
	ProfilePath        string  `json:"profile_path"`
	CastID             int     `json:"cast_id"`
	Character          string  `json:"character"`
	CreditID           string  `json:"credit_id"`
	Order              int     `json:"order"`
}

// CrewMember represents a crew member from credits
type CrewMember struct {
	Adult              bool    `json:"adult"`
	Gender             int     `json:"gender"`
	ID                 int     `json:"id"`
	KnownForDepartment string  `json:"known_for_department"`
	Name               string  `json:"name"`
	OriginalName       string  `json:"original_name"`
	Popularity         float64 `json:"popularity"`
	ProfilePath        string  `json:"profile_path"`
	CreditID           string  `json:"credit_id"`
	Department         string  `json:"department"`
	Job                string  `json:"job"`
}

// Credits represents the credits response from TMDB
type Credits struct {
	ID   int          `json:"id"`
	Cast []CastMember `json:"cast"`
	Crew []CrewMember `json:"crew"`
}

// MovieActor represents the association between movie and actor
type MovieActor struct {
	MovieID int `json:"movie_id"`
	ActorID int `json:"actor_id"`
}

// TMDBGenres contains all the genre mappings
var TMDBGenres = []Genre{
	{28, "Action"},
	{12, "Adventure"},
	{16, "Animation"},
	{35, "Comedy"},
	{80, "Crime"},
	{99, "Documentary"},
	{18, "Drama"},
	{10751, "Family"},
	{14, "Fantasy"},
	{36, "History"},
	{27, "Horror"},
	{10402, "Music"},
	{9648, "Mystery"},
	{10749, "Romance"},
	{878, "Science Fiction"},
	{10770, "TV Movie"},
	{53, "Thriller"},
	{10752, "War"},
	{37, "Western"},
}

type TMDBResponse struct {
	Page         int     `json:"page"`
	Results      []Movie `json:"results"`
	TotalPages   int     `json:"total_pages"`
	TotalResults int     `json:"total_results"`
}

// DownloadResult represents the result of downloading images for a movie
type DownloadResult struct {
	MovieID       int    `json:"movie_id"`
	Title         string `json:"title"`
	PosterSaved   bool   `json:"poster_saved"`
	BackdropSaved bool   `json:"backdrop_saved"`
	PosterPath    string `json:"poster_path,omitempty"`
	BackdropPath  string `json:"backdrop_path,omitempty"`
	SQLGenerated  bool   `json:"sql_generated"`
	DirectorName  string `json:"director_name,omitempty"`
	ActorsCount   int    `json:"actors_count"`
	Error         string `json:"error,omitempty"`
}

// fetchMovieCredits fetches movie credits (cast and crew) from TMDB
func fetchMovieCredits(movieID int) (*Credits, error) {
	url := fmt.Sprintf("%s/movie/%d/credits?language=en-US", TMDB_BASE_URL, movieID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", AUTH_TOKEN)

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("credits API request failed with status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var credits Credits
	if err := json.Unmarshal(body, &credits); err != nil {
		return nil, err
	}

	return &credits, nil
}

// fetchMovieDetails fetches detailed movie information including runtime
func fetchMovieDetails(movieID int) (*Movie, error) {
	url := fmt.Sprintf("%s/movie/%d?language=en-US", TMDB_BASE_URL, movieID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", AUTH_TOKEN)

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var movie Movie
	if err := json.Unmarshal(body, &movie); err != nil {
		return nil, err
	}

	return &movie, nil
}

// getDirectorFromCredits extracts the director from credits
func getDirectorFromCredits(credits *Credits) *Person {
	for _, crew := range credits.Crew {
		if crew.Job == "Director" {
			return &Person{
				ID:          crew.ID,
				Name:        crew.Name,
				ProfilePath: crew.ProfilePath,
			}
		}
	}
	return nil
}

// getTop3ActorsFromCredits extracts the first 3 actors from cast
func getTop3ActorsFromCredits(credits *Credits) []Person {
	var actors []Person
	count := 0

	for _, cast := range credits.Cast {
		if cast.KnownForDepartment == "Acting" && count < 3 {
			actors = append(actors, Person{
				ID:          cast.ID,
				Name:        cast.Name,
				ProfilePath: cast.ProfilePath,
			})
			count++
		}
	}

	return actors
}

// generateSQLSeeds generates SQL INSERT statements for all tables including people and movie_actors
func generateSQLSeeds(movies []Movie, allPeople []Person, movieActors []MovieActor) string {
	var sql strings.Builder

	// Header comment
	sql.WriteString("-- Database seed for movies, genres, people, and movie_actors tables\n")
	sql.WriteString("-- Generated by TMDB Movie Downloader with Credits\n\n")

	// Insert genres first
	sql.WriteString("-- Insert genres\n")
	sql.WriteString("INSERT INTO genres (id, name) VALUES\n")
	for i, genre := range TMDBGenres {
		if i > 0 {
			sql.WriteString(",\n")
		}
		sql.WriteString(fmt.Sprintf("    (%d, '%s')", genre.ID, genre.Name))
	}
	sql.WriteString("\nON CONFLICT (id) DO NOTHING;\n\n")

	// Insert people (actors and directors)
	if len(allPeople) > 0 {
		sql.WriteString("-- Insert people (actors and directors)\n")
		sql.WriteString("INSERT INTO people (id, name) VALUES\n")
		for i, person := range allPeople {
			if i > 0 {
				sql.WriteString(",\n")
			}
			name := strings.ReplaceAll(person.Name, "'", "''")
			sql.WriteString(fmt.Sprintf("    (%d, '%s')", person.ID, name))
		}
		sql.WriteString("\nON CONFLICT (id) DO NOTHING;\n\n")
	}

	// Insert movies
	sql.WriteString("-- Insert movies\n")
	for _, movie := range movies {
		title := strings.ReplaceAll(movie.Title, "'", "''")
		synopsis := strings.ReplaceAll(movie.Overview, "'", "''")

		// Handle NULL runtime
		runtimeStr := "NULL"
		if movie.Runtime > 0 {
			runtimeStr = fmt.Sprintf("%d", movie.Runtime)
		}

		// Handle release_date format (convert from YYYY-MM-DD to proper date)
		releaseDateStr := "NULL"
		if movie.ReleaseDate != "" {
			releaseDateStr = fmt.Sprintf("'%s'", movie.ReleaseDate)
		}

		// Handle director_id
		directorIDStr := "NULL"
		if movie.DirectorID != nil {
			directorIDStr = fmt.Sprintf("%d", *movie.DirectorID)
		}

		sql.WriteString(fmt.Sprintf(
			"INSERT INTO movies (title, synopsis, poster_img, backdrop_img, duration_minutes, release_date, director_id) VALUES ('%s', '%s', '%s', '%s', %s, %s, %s);\n",
			title,
			synopsis,
			movie.PosterPath,
			movie.BackdropPath,
			runtimeStr,
			releaseDateStr,
			directorIDStr,
		))
	}
	sql.WriteString("\n")

	// Insert movie_genres associations
	sql.WriteString("-- Insert movie_genres associations\n")
	for _, movie := range movies {
		for _, genreID := range movie.GenreIds {
			sql.WriteString(fmt.Sprintf(
				"INSERT INTO movie_genres (movie_id, genre_id) VALUES (%d, %d) ON CONFLICT DO NOTHING;\n",
				movie.ID,
				genreID,
			))
		}
	}
	sql.WriteString("\n")

	// Insert movie_actors associations
	if len(movieActors) > 0 {
		sql.WriteString("-- Insert movie_actors associations\n")
		for _, ma := range movieActors {
			sql.WriteString(fmt.Sprintf(
				"INSERT INTO movie_actors (movie_id, actor_id) VALUES (%d, %d) ON CONFLICT DO NOTHING;\n",
				ma.MovieID,
				ma.ActorID,
			))
		}
	}

	return sql.String()
}

// initSQLFile creates/initializes the SQL file with database schema
func initSQLFile(filename string) error {
	file, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer file.Close()

	schemaSQL := `-- Database seed for movies, genres, people, and movie_actors tables
-- Generated by TMDB Movie Downloader with Credits

-- Note: This assumes your tables already exist. 
-- If you need to create them, uncomment and modify the CREATE TABLE statements below.

/*
CREATE TABLE IF NOT EXISTS genres (
    id INTEGER PRIMARY KEY,
    name VARCHAR(20) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS people (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL
);

CREATE TABLE IF NOT EXISTS movies (
    id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
    title TEXT NOT NULL,
    synopsis TEXT,
    poster_img TEXT,
    backdrop_img TEXT,
    duration_minutes INTEGER,
    release_date DATE,
    director_id INTEGER,
    age_rating_id INTEGER,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    archived_at TIMESTAMPTZ,
    FOREIGN KEY (director_id) REFERENCES people(id)
);

CREATE TABLE IF NOT EXISTS movie_genres (
    movie_id INTEGER NOT NULL,
    genre_id INTEGER NOT NULL,
    PRIMARY KEY (movie_id, genre_id),
    FOREIGN KEY (movie_id) REFERENCES movies(id),
    FOREIGN KEY (genre_id) REFERENCES genres(id)
);

CREATE TABLE IF NOT EXISTS movie_actors (
    actor_id INTEGER NOT NULL,
    movie_id INTEGER NOT NULL,
    PRIMARY KEY (actor_id, movie_id),
    FOREIGN KEY (actor_id) REFERENCES people(id),
    FOREIGN KEY (movie_id) REFERENCES movies(id)
);
*/

`

	_, err = file.WriteString(schemaSQL)
	return err
}

// writeSQLToFile writes SQL content to file
func writeSQLToFile(filename, sqlContent string) error {
	file, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = file.WriteString(sqlContent)
	return err
}

func createDirectories() error {
	dirs := []string{"images/posters", "images/backdrops"}
	for _, dir := range dirs {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("failed to create directory %s: %v", dir, err)
		}
	}
	return nil
}

// fetchMovies fetches movies from TMDB API
func fetchMovies(page int) (*TMDBResponse, error) {
	url := fmt.Sprintf("%s/discover/movie?include_adult=false&include_video=false&language=en-US&page=%d&sort_by=popularity.desc", TMDB_BASE_URL, page)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("accept", "application/json")
	req.Header.Add("Authorization", AUTH_TOKEN)

	res, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API request failed with status: %d", res.StatusCode)
	}

	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, err
	}

	var tmdbResponse TMDBResponse
	if err := json.Unmarshal(body, &tmdbResponse); err != nil {
		return nil, err
	}

	return &tmdbResponse, nil
}

// downloadImage downloads an image from the given URL and saves it to the specified path
func downloadImage(imageURL, savePath string) error {
	if imageURL == "" {
		return fmt.Errorf("empty image URL")
	}

	fullURL := IMAGE_BASE_URL + imageURL

	resp, err := http.Get(fullURL)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("failed to download image, status: %d", resp.StatusCode)
	}

	file, err := os.Create(savePath)
	if err != nil {
		return err
	}
	defer file.Close()

	_, err = io.Copy(file, resp.Body)
	return err
}

// sanitizeFilename removes/replaces characters that are not safe for filenames
func sanitizeFilename(filename string) string {
	// Replace unsafe characters with underscores
	unsafe := []string{"/", "\\", ":", "*", "?", "\"", "<", ">", "|"}
	for _, char := range unsafe {
		filename = strings.ReplaceAll(filename, char, "_")
	}
	return filename
}

// downloadMovieImages downloads poster and backdrop for a single movie
func downloadMovieImages(movie Movie) DownloadResult {
	result := DownloadResult{
		MovieID: movie.ID,
		Title:   movie.Title,
	}

	sanitizedTitle := sanitizeFilename(movie.Title)

	// Download poster
	if movie.PosterPath != "" {
		posterFilename := fmt.Sprintf("%d_%s_poster%s", movie.ID, sanitizedTitle, filepath.Ext(movie.PosterPath))
		posterPath := filepath.Join("images", "posters", posterFilename)

		if err := downloadImage(movie.PosterPath, posterPath); err != nil {
			result.Error += fmt.Sprintf("Poster download failed: %v; ", err)
		} else {
			result.PosterSaved = true
			result.PosterPath = posterPath
		}
	}

	// Download backdrop
	if movie.BackdropPath != "" {
		backdropFilename := fmt.Sprintf("%d_%s_backdrop%s", movie.ID, sanitizedTitle, filepath.Ext(movie.BackdropPath))
		backdropPath := filepath.Join("images", "backdrops", backdropFilename)

		if err := downloadImage(movie.BackdropPath, backdropPath); err != nil {
			result.Error += fmt.Sprintf("Backdrop download failed: %v; ", err)
		} else {
			result.BackdropSaved = true
			result.BackdropPath = backdropPath
		}
	}

	return result
}

// processMovieWithCredits processes a single movie including fetching credits
func processMovieWithCredits(movie Movie) (Movie, []Person, []MovieActor, DownloadResult, error) {
	var allPeople []Person
	var movieActors []MovieActor
	result := DownloadResult{
		MovieID: movie.ID,
		Title:   movie.Title,
	}

	// Fetch detailed movie information
	detailedMovie, err := fetchMovieDetails(movie.ID)
	if err != nil {
		fmt.Printf("Warning: Could not fetch details for movie %d: %v\n", movie.ID, err)
		detailedMovie = &movie
	}

	// Fetch credits
	credits, err := fetchMovieCredits(movie.ID)
	if err != nil {
		fmt.Printf("Warning: Could not fetch credits for movie %d: %v\n", movie.ID, err)
		result.Error += fmt.Sprintf("Credits fetch failed: %v; ", err)
	} else {
		// Get director
		if director := getDirectorFromCredits(credits); director != nil {
			detailedMovie.DirectorID = &director.ID
			detailedMovie.DirectorName = director.Name
			allPeople = append(allPeople, *director)
			result.DirectorName = director.Name
		}

		// Get top 3 actors
		actors := getTop3ActorsFromCredits(credits)
		for _, actor := range actors {
			allPeople = append(allPeople, actor)
			movieActors = append(movieActors, MovieActor{
				MovieID: movie.ID,
				ActorID: actor.ID,
			})
		}
		result.ActorsCount = len(actors)
	}

	// Download images
	imageResult := downloadMovieImages(*detailedMovie)
	result.PosterSaved = imageResult.PosterSaved
	result.BackdropSaved = imageResult.BackdropSaved
	result.PosterPath = imageResult.PosterPath
	result.BackdropPath = imageResult.BackdropPath
	if imageResult.Error != "" {
		result.Error += imageResult.Error
	}

	return *detailedMovie, allPeople, movieActors, result, nil
}

// removeDuplicatePeople removes duplicate people from the slice
func removeDuplicatePeople(people []Person) []Person {
	seen := make(map[int]bool)
	var result []Person

	for _, person := range people {
		if !seen[person.ID] {
			seen[person.ID] = true
			result = append(result, person)
		}
	}

	return result
}

// fetchAndDownload200Movies fetches and downloads images for 200 movies with credits
func fetchAndDownload200Movies() error {
	fmt.Println("Starting to fetch and download 200 popular movies with credits...")

	// Initialize SQL file
	sqlFilename := "movie_seeds_with_credits.sql"
	if err := initSQLFile(sqlFilename); err != nil {
		return fmt.Errorf("failed to initialize SQL file: %v", err)
	}
	fmt.Printf("SQL file '%s' initialized\n", sqlFilename)

	var allResults []DownloadResult
	var allMovies []Movie
	var allPeople []Person
	var allMovieActors []MovieActor
	totalMovies := 0

	// Fetch movies from multiple pages to get 200 movies
	for page := 1; totalMovies < 200; page++ {
		fmt.Printf("Fetching page %d...\n", page)

		tmdbResponse, err := fetchMovies(page)
		if err != nil {
			return fmt.Errorf("failed to fetch movies from page %d: %v", page, err)
		}

		// Process movies from this page
		moviesFromThisPage := 0
		for _, movie := range tmdbResponse.Results {
			if totalMovies >= 200 {
				break
			}

			fmt.Printf("Processing movie %d: %s\n", movie.ID, movie.Title)

			// Process movie with credits
			processedMovie, people, movieActors, result, err := processMovieWithCredits(movie)
			if err != nil {
				fmt.Printf("Error processing movie %d: %v\n", movie.ID, err)
				continue
			}

			allResults = append(allResults, result)
			allMovies = append(allMovies, processedMovie)
			allPeople = append(allPeople, people...)
			allMovieActors = append(allMovieActors, movieActors...)

			totalMovies++
			moviesFromThisPage++
		}

		fmt.Printf("Processed %d movies from page %d\n", moviesFromThisPage, page)

		// If we didn't get any movies from this page, break to avoid infinite loop
		if len(tmdbResponse.Results) == 0 {
			break
		}
	}

	// Remove duplicate people
	allPeople = removeDuplicatePeople(allPeople)

	// Generate and write SQL seeds for all movies
	fmt.Println("Generating SQL seeds...")
	sqlSeeds := generateSQLSeeds(allMovies, allPeople, allMovieActors)
	if err := writeSQLToFile(sqlFilename, sqlSeeds); err != nil {
		return fmt.Errorf("failed to write SQL seeds: %v", err)
	}

	// Print summary
	fmt.Printf("\n=== DOWNLOAD SUMMARY ===\n")
	fmt.Printf("Total movies processed: %d\n", totalMovies)

	postersDownloaded := 0
	backdropsDownloaded := 0
	moviesWithDirectors := 0
	totalActors := 0
	errors := 0

	for _, result := range allResults {
		if result.PosterSaved {
			postersDownloaded++
		}
		if result.BackdropSaved {
			backdropsDownloaded++
		}
		if result.DirectorName != "" {
			moviesWithDirectors++
		}
		totalActors += result.ActorsCount
		if result.Error != "" {
			errors++
			fmt.Printf("Error for '%s': %s\n", result.Title, result.Error)
		}
	}

	fmt.Printf("Posters downloaded: %d\n", postersDownloaded)
	fmt.Printf("Backdrops downloaded: %d\n", backdropsDownloaded)
	fmt.Printf("Movies with directors: %d\n", moviesWithDirectors)
	fmt.Printf("Total actors processed: %d\n", totalActors)
	fmt.Printf("Unique people: %d\n", len(allPeople))
	fmt.Printf("Movie-actor associations: %d\n", len(allMovieActors))
	fmt.Printf("SQL seeds generated: %s\n", sqlFilename)
	fmt.Printf("Movies with errors: %d\n", errors)
	fmt.Println("SQL file contains:")
	fmt.Printf("  - %d genre records\n", len(TMDBGenres))
	fmt.Printf("  - %d people records (actors + directors)\n", len(allPeople))
	fmt.Printf("  - %d movie records\n", len(allMovies))
	fmt.Printf("  - Movie-genre associations\n")
	fmt.Printf("  - Movie-actor associations\n")
	fmt.Println("======================")

	return nil
}

func main() {
	// Create necessary directories
	if err := createDirectories(); err != nil {
		fmt.Printf("Error creating directories: %v\n", err)
		return
	}

	// Automatically fetch and download 200 movies with credits
	if err := fetchAndDownload200Movies(); err != nil {
		fmt.Printf("Error during automatic download: %v\n", err)
		return
	}

	fmt.Println("\nProcess completed successfully!")
}
